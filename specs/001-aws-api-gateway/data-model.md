# Data Model: AWS RAG System

## Core Entities

### Document Entity
```go
type Document struct {
    ID          string    `json:"id" dynamodb:"id"`
    FileName    string    `json:"fileName" dynamodb:"fileName"`
    FileSize    int64     `json:"fileSize" dynamodb:"fileSize"`
    FileType    string    `json:"fileType" dynamodb:"fileType"` // "txt" | "md"
    S3Key       string    `json:"s3Key" dynamodb:"s3Key"`
    S3Bucket    string    `json:"s3Bucket" dynamodb:"s3Bucket"`
    UploadedAt  time.Time `json:"uploadedAt" dynamodb:"uploadedAt"`
    Status      string    `json:"status" dynamodb:"status"` // "uploading" | "processing" | "ready" | "error"
    KBStatus    string    `json:"kbStatus" dynamodb:"kbStatus"` // Knowledge Base sync status
    ErrorMsg    string    `json:"errorMsg,omitempty" dynamodb:"errorMsg,omitempty"`
}
```

**Validation Rules**:
- ID: UUID v4 format required
- FileName: non-empty, max 255 chars
- FileSize: 0 < size <= 50MB
- FileType: must be "txt" or "md"
- Status: enum values only

**State Transitions**:
uploading → processing → ready
uploading → error (validation/upload failure)
processing → error (Knowledge Base sync failure)

### Query Entity
```go
type Query struct {
    ID          string    `json:"id" dynamodb:"id"`
    Question    string    `json:"question" dynamodb:"question"`
    Timestamp   time.Time `json:"timestamp" dynamodb:"timestamp"`
    SessionID   string    `json:"sessionId" dynamodb:"sessionId"` // Browser session
    Status      string    `json:"status" dynamodb:"status"` // "processing" | "completed" | "error"
    ResponseID  string    `json:"responseId,omitempty" dynamodb:"responseId,omitempty"`
}
```

**Validation Rules**:
- ID: UUID v4 format required
- Question: non-empty, max 1000 chars, Japanese/English text
- SessionID: UUID v4 format (generated by frontend)
- Status: enum values only

### Response Entity
```go
type Response struct {
    ID              string           `json:"id" dynamodb:"id"`
    QueryID         string           `json:"queryId" dynamodb:"queryId"`
    Answer          string           `json:"answer" dynamodb:"answer"`
    Sources         []SourceDocument `json:"sources" dynamodb:"sources"`
    Timestamp       time.Time        `json:"timestamp" dynamodb:"timestamp"`
    ModelUsed       string           `json:"modelUsed" dynamodb:"modelUsed"`
    ProcessingTime  int              `json:"processingTimeMs" dynamodb:"processingTimeMs"`
    TokensUsed      int              `json:"tokensUsed" dynamodb:"tokensUsed"`
}

type SourceDocument struct {
    DocumentID   string  `json:"documentId"`
    FileName     string  `json:"fileName"`
    Excerpt      string  `json:"excerpt"`
    Confidence   float64 `json:"confidence"`
    ChunkIndex   int     `json:"chunkIndex"`
}
```

**Validation Rules**:
- ID: UUID v4 format required
- Answer: non-empty, max 5000 chars
- Sources: max 5 source documents
- Confidence: 0.0 <= confidence <= 1.0

### UploadSession Entity (for large file handling)
```go
type UploadSession struct {
    ID            string    `json:"id" dynamodb:"id"`
    FileName      string    `json:"fileName" dynamodb:"fileName"`
    FileSize      int64     `json:"fileSize" dynamodb:"fileSize"`
    FileType      string    `json:"fileType" dynamodb:"fileType"`
    UploadURL     string    `json:"uploadUrl" dynamodb:"uploadUrl"` // Pre-signed S3 URL
    CreatedAt     time.Time `json:"createdAt" dynamodb:"createdAt"`
    ExpiresAt     time.Time `json:"expiresAt" dynamodb:"expiresAt"`
    Status        string    `json:"status" dynamodb:"status"` // "created" | "completed" | "expired"
}
```

## Data Relationships

```
UploadSession (1) → Document (1) [upload completion]
Query (1) → Response (1) [question-answer pair]
Response (1) → SourceDocument (*) [answer sources]
Document (*) ← SourceDocument (*) [source references]
```

## Storage Strategy

### DynamoDB Tables

**Documents Table**:
- Primary Key: id (String)
- GSI: status-uploadedAt-index (query by status, sort by time)
- TTL: None (permanent storage)

**Queries Table**:
- Primary Key: id (String) 
- GSI: sessionId-timestamp-index (session history)
- TTL: 30 days (automatic cleanup)

**Responses Table**:
- Primary Key: id (String)
- GSI: queryId-index (lookup by query)
- TTL: 30 days (automatic cleanup)

**UploadSessions Table**:
- Primary Key: id (String)
- TTL: expiresAt (24h automatic cleanup)

### S3 Structure
```
poc-ragbkb-documents/
├── documents/
│   └── {document-id}/{original-filename}
└── knowledge-base/
    └── {auto-generated-by-bedrock}/
```

## Frontend Data Models

### TypeScript Interfaces
```typescript
interface Document {
  id: string;
  fileName: string;
  fileSize: number;
  fileType: 'txt' | 'md';
  uploadedAt: string; // ISO datetime
  status: 'uploading' | 'processing' | 'ready' | 'error';
  errorMsg?: string;
}

interface Query {
  id: string;
  question: string;
  timestamp: string; // ISO datetime
  sessionId: string;
}

interface Response {
  id: string;
  answer: string;
  sources: SourceDocument[];
  timestamp: string;
  processingTimeMs: number;
}

interface SourceDocument {
  documentId: string;
  fileName: string;
  excerpt: string;
  confidence: number;
}

interface UploadSession {
  id: string;
  fileName: string;
  fileSize: number;
  uploadUrl: string;
  expiresAt: string;
}
```

## Data Flow

1. **Document Upload Flow**:
   UploadSession created → Pre-signed URL → S3 upload → Document created → Knowledge Base sync

2. **Query Flow**:
   Query created → Bedrock Knowledge Base search → Response generated → Sources linked

3. **Error Handling**:
   All entities support error states with descriptive messages
   Failed uploads/queries tracked for debugging

## Performance Considerations

- DynamoDB read/write capacity: On-demand for variable traffic
- S3 lifecycle: Intelligent tiering for cost optimization
- Query response caching: Client-side 5-minute cache
- Large file handling: Multi-part upload via pre-signed URLs
